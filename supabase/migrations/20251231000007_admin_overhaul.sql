-- Admin, provider, and content management overhaul
-- Generated by Codex agent to replace email-based admin checks with role-based access
-- and to back the admin panel with proper persistence.

-- Ensure pgcrypto available for API key encryption
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- -----------------------------------------------------------------------------
-- User roles & helpers
-- -----------------------------------------------------------------------------
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'user_profiles'
      AND column_name = 'role'
  ) THEN
    ALTER TABLE public.user_profiles
      ADD COLUMN role TEXT NOT NULL DEFAULT 'user'
      CHECK (role IN ('user', 'admin', 'moderator'));
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_user_profiles_role ON public.user_profiles(role);

CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT COALESCE(
    (
      SELECT TRUE
      FROM public.user_profiles up
      WHERE up.user_id = auth.uid()
        AND up.role = 'admin'
      LIMIT 1
    ), FALSE
  );
$$;

GRANT EXECUTE ON FUNCTION public.is_admin() TO authenticated;
GRANT EXECUTE ON FUNCTION public.is_admin() TO anon;
GRANT EXECUTE ON FUNCTION public.is_admin() TO service_role;

CREATE OR REPLACE FUNCTION public.promote_user_to_admin(p_email text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile_id uuid;
BEGIN
  IF COALESCE(auth.role(), '') <> 'service_role' THEN
    RAISE EXCEPTION 'insufficient_privileges';
  END IF;

  SELECT id
    INTO v_profile_id
    FROM public.user_profiles
    WHERE lower(email) = lower(p_email)
    LIMIT 1;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'user_not_found';
  END IF;

  UPDATE public.user_profiles
  SET role = 'admin'
  WHERE id = v_profile_id;
END;
$$;

REVOKE ALL ON FUNCTION public.promote_user_to_admin(text) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.promote_user_to_admin(text) TO service_role;

-- -----------------------------------------------------------------------------
-- Provider credential storage
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.provider_credentials (
  provider_id UUID PRIMARY KEY REFERENCES public.providers(id) ON DELETE CASCADE,
  encrypted_api_key BYTEA NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.provider_credentials ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Admins manage provider credentials" ON public.provider_credentials;
CREATE POLICY "Admins manage provider credentials"
  ON public.provider_credentials
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

CREATE OR REPLACE FUNCTION public.store_provider_api_key(p_provider_id uuid, p_api_key text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_encryption_key text;
BEGIN
  v_encryption_key := current_setting('app.settings.provider_encryption_key', true);

  IF v_encryption_key IS NULL OR v_encryption_key = '' THEN
    RAISE EXCEPTION 'provider_encryption_key_not_configured';
  END IF;

  IF COALESCE(auth.role(), '') <> 'service_role' AND NOT public.is_admin() THEN
    RAISE EXCEPTION 'insufficient_privileges';
  END IF;

  INSERT INTO public.provider_credentials(provider_id, encrypted_api_key)
  VALUES (p_provider_id, pgp_sym_encrypt(p_api_key, v_encryption_key))
  ON CONFLICT (provider_id)
  DO UPDATE
  SET encrypted_api_key = EXCLUDED.encrypted_api_key,
      updated_at = now();
END;
$$;

REVOKE ALL ON FUNCTION public.store_provider_api_key(uuid, text) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.store_provider_api_key(uuid, text) TO authenticated;
GRANT EXECUTE ON FUNCTION public.store_provider_api_key(uuid, text) TO service_role;

CREATE OR REPLACE FUNCTION public.get_provider_api_key(p_provider_id uuid)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_encryption_key text;
  v_api_key text;
BEGIN
  v_encryption_key := current_setting('app.settings.provider_encryption_key', true);

  IF v_encryption_key IS NULL OR v_encryption_key = '' THEN
    RAISE EXCEPTION 'provider_encryption_key_not_configured';
  END IF;

  IF COALESCE(auth.role(), '') <> 'service_role' AND NOT public.is_admin() THEN
    RAISE EXCEPTION 'insufficient_privileges';
  END IF;

  SELECT pgp_sym_decrypt(encrypted_api_key, v_encryption_key)::text
    INTO v_api_key
    FROM public.provider_credentials
    WHERE provider_id = p_provider_id;

  RETURN v_api_key;
END;
$$;

REVOKE ALL ON FUNCTION public.get_provider_api_key(uuid) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.get_provider_api_key(uuid) TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_provider_api_key(uuid) TO service_role;

DROP TRIGGER IF EXISTS update_provider_credentials_updated_at ON public.provider_credentials;
CREATE TRIGGER update_provider_credentials_updated_at
  BEFORE UPDATE ON public.provider_credentials
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- -----------------------------------------------------------------------------
-- Content management tables (affirmations & challenge templates)
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.affirmations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  content TEXT NOT NULL,
  category TEXT NOT NULL DEFAULT 'self-love',
  tone TEXT,
  tags TEXT[] DEFAULT ARRAY[]::TEXT[],
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_by UUID REFERENCES public.user_profiles(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.affirmations ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Everyone can view affirmations" ON public.affirmations;
CREATE POLICY "Everyone can view affirmations"
  ON public.affirmations
  FOR SELECT
  USING (true);

DROP POLICY IF EXISTS "Admins manage affirmations" ON public.affirmations;
CREATE POLICY "Admins manage affirmations"
  ON public.affirmations
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP TRIGGER IF EXISTS update_affirmations_updated_at ON public.affirmations;
CREATE TRIGGER update_affirmations_updated_at
  BEFORE UPDATE ON public.affirmations
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

CREATE INDEX IF NOT EXISTS idx_affirmations_category ON public.affirmations(category);
CREATE INDEX IF NOT EXISTS idx_affirmations_active ON public.affirmations(is_active);

CREATE TABLE IF NOT EXISTS public.challenge_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  description TEXT,
  category TEXT NOT NULL DEFAULT 'connection',
  questions JSONB NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_by UUID REFERENCES public.user_profiles(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

ALTER TABLE public.challenge_templates ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Everyone can view challenge templates" ON public.challenge_templates;
CREATE POLICY "Everyone can view challenge templates"
  ON public.challenge_templates
  FOR SELECT
  USING (is_active = true);

DROP POLICY IF EXISTS "Admins manage challenge templates" ON public.challenge_templates;
CREATE POLICY "Admins manage challenge templates"
  ON public.challenge_templates
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP TRIGGER IF EXISTS update_challenge_templates_updated_at ON public.challenge_templates;
CREATE TRIGGER update_challenge_templates_updated_at
  BEFORE UPDATE ON public.challenge_templates
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

CREATE INDEX IF NOT EXISTS idx_challenge_templates_category ON public.challenge_templates(category);
CREATE INDEX IF NOT EXISTS idx_challenge_templates_active ON public.challenge_templates(is_active);

-- -----------------------------------------------------------------------------
-- Session controls
-- -----------------------------------------------------------------------------
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'sessions'
      AND column_name = 'is_muted'
  ) THEN
    ALTER TABLE public.sessions
      ADD COLUMN is_muted BOOLEAN NOT NULL DEFAULT false;
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_sessions_is_muted ON public.sessions(is_muted);

-- -----------------------------------------------------------------------------
-- Replace admin email checks across policies with role-based helper
-- -----------------------------------------------------------------------------

-- Providers ecosystem --------------------------------------------------------
DROP POLICY IF EXISTS "Admins can manage providers" ON public.providers;
CREATE POLICY "Admins can manage providers"
  ON public.providers
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admin can insert providers" ON public.providers;
DROP POLICY IF EXISTS "Admin can update providers" ON public.providers;
DROP POLICY IF EXISTS "Admin can delete providers" ON public.providers;

DROP POLICY IF EXISTS "Admins can manage models" ON public.models;
CREATE POLICY "Admins can manage models"
  ON public.models
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admin can insert models" ON public.models;
DROP POLICY IF EXISTS "Admin can update models" ON public.models;
DROP POLICY IF EXISTS "Admin can delete models" ON public.models;

DROP POLICY IF EXISTS "Admins can manage voices" ON public.voices;
CREATE POLICY "Admins can manage voices"
  ON public.voices
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admin can insert voices" ON public.voices;
DROP POLICY IF EXISTS "Admin can update voices" ON public.voices;
DROP POLICY IF EXISTS "Admin can delete voices" ON public.voices;

DROP POLICY IF EXISTS "Admins can manage prompts" ON public.prompts;
CREATE POLICY "Admins can manage prompts"
  ON public.prompts
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage agents" ON public.agents;
CREATE POLICY "Admins can manage agents"
  ON public.agents
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

-- Sessions & analytics -------------------------------------------------------
DROP POLICY IF EXISTS "Admins can manage all sessions" ON public.sessions;
CREATE POLICY "Admins can manage all sessions"
  ON public.sessions
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage all session events" ON public.session_events;
CREATE POLICY "Admins can manage all session events"
  ON public.session_events
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

-- Assessments & conversations -----------------------------------------------
DROP POLICY IF EXISTS "Admins can manage assessments" ON public.assessments;
CREATE POLICY "Admins can manage assessments"
  ON public.assessments
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can view all assessment results" ON public.assessment_results;
CREATE POLICY "Admins can view all assessment results"
  ON public.assessment_results
  FOR SELECT
  TO authenticated
  USING (public.is_admin());

DROP POLICY IF EXISTS "Admins can view all conversations" ON public.conversations;
CREATE POLICY "Admins can view all conversations"
  ON public.conversations
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can view all messages" ON public.messages;
CREATE POLICY "Admins can view all messages"
  ON public.messages
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

-- Gamification ---------------------------------------------------------------
DROP POLICY IF EXISTS "Admins can manage achievements" ON public.achievements;
CREATE POLICY "Admins can manage achievements"
  ON public.achievements
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can view all user achievements" ON public.user_achievements;
CREATE POLICY "Admins can view all user achievements"
  ON public.user_achievements
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can view all transactions" ON public.crystal_transactions;
CREATE POLICY "Admins can view all transactions"
  ON public.crystal_transactions
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage level thresholds" ON public.level_thresholds;
CREATE POLICY "Admins can manage level thresholds"
  ON public.level_thresholds
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

-- Profiles & memories --------------------------------------------------------
DROP POLICY IF EXISTS "Admins can manage all profiles" ON public.user_profiles;
CREATE POLICY "Admins can manage all profiles"
  ON public.user_profiles
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage all memory profiles" ON public.user_memory_profiles;
CREATE POLICY "Admins can manage all memory profiles"
  ON public.user_memory_profiles
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

-- Community & wellness -------------------------------------------------------
DROP POLICY IF EXISTS "Admins can manage content" ON public.wellness_resources;
CREATE POLICY "Admins can manage content"
  ON public.wellness_resources
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage community connections" ON public.community_connections;
CREATE POLICY "Admins can manage community connections"
  ON public.community_connections
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage couples challenges" ON public.couples_challenges;
CREATE POLICY "Admins can manage couples challenges"
  ON public.couples_challenges
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

-- -----------------------------------------------------------------------------
-- Seed starter records for new tables so UI has baseline content
-- -----------------------------------------------------------------------------
INSERT INTO public.affirmations (content, category, tone, tags, created_by)
SELECT 'I am worthy of the love I pour into others.', 'self-love', 'gentle', ARRAY['morning','confidence'], id
FROM public.user_profiles
WHERE role = 'admin'
LIMIT 1
ON CONFLICT DO NOTHING;

INSERT INTO public.challenge_templates (title, description, category, questions, created_by)
SELECT 'Evening Reflection', 'Build deeper connection with short reflective prompts.', 'intimacy',
       '["What made you feel seen today?","How can we support each other tomorrow?","What is one gratitude you want to share?"]'::jsonb,
       id
FROM public.user_profiles
WHERE role = 'admin'
LIMIT 1
ON CONFLICT DO NOTHING;

-- Additional community policy migrations
DROP POLICY IF EXISTS "Admins can manage all connections" ON public.community_connections;
CREATE POLICY "Admins can manage all connections"
  ON public.community_connections
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage all challenges" ON public.couples_challenges;
CREATE POLICY "Admins can manage all challenges"
  ON public.couples_challenges
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage all challenge responses" ON public.couples_challenge_responses;
CREATE POLICY "Admins can manage all challenge responses"
  ON public.couples_challenge_responses
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage all subscriptions" ON public.subscriptions;
CREATE POLICY "Admins can manage all subscriptions"
  ON public.subscriptions
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage all subscription transactions" ON public.subscription_transactions;
CREATE POLICY "Admins can manage all subscription transactions"
  ON public.subscription_transactions
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage all resources" ON public.wellness_resources;
CREATE POLICY "Admins can manage all resources"
  ON public.wellness_resources
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can view all resource progress" ON public.user_resource_progress;
CREATE POLICY "Admins can view all resource progress"
  ON public.user_resource_progress
  FOR SELECT
  TO authenticated
  USING (public.is_admin());

-- Community chat & announcement administration
DROP POLICY IF EXISTS "Admins can manage chat rooms" ON public.community_chat_rooms;
CREATE POLICY "Admins can manage chat rooms"
  ON public.community_chat_rooms
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage all messages" ON public.community_chat_messages;
CREATE POLICY "Admins can manage all messages"
  ON public.community_chat_messages
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage announcements" ON public.community_announcements;
CREATE POLICY "Admins can manage announcements"
  ON public.community_announcements
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can view all announcement reads" ON public.community_announcement_reads;
CREATE POLICY "Admins can view all announcement reads"
  ON public.community_announcement_reads
  FOR SELECT
  TO authenticated
  USING (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage challenge announcements" ON public.community_challenge_announcements;
CREATE POLICY "Admins can manage challenge announcements"
  ON public.community_challenge_announcements
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage assessment announcements" ON public.community_assessment_announcements;
CREATE POLICY "Admins can manage assessment announcements"
  ON public.community_assessment_announcements
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

DROP POLICY IF EXISTS "Admins can manage quiz announcements" ON public.community_quiz_announcements;
CREATE POLICY "Admins can manage quiz announcements"
  ON public.community_quiz_announcements
  FOR ALL
  TO authenticated
  USING (public.is_admin())
  WITH CHECK (public.is_admin());

-- Align seeded records with new admin role metadata
WITH admin_profile AS (
  SELECT user_id
  FROM public.user_profiles
  WHERE role = 'admin'
  ORDER BY created_at
  LIMIT 1
)
UPDATE public.community_chat_rooms
SET created_by = admin_profile.user_id
FROM admin_profile
WHERE created_by IS NULL;

WITH admin_profile AS (
  SELECT user_id
  FROM public.user_profiles
  WHERE role = 'admin'
  ORDER BY created_at
  LIMIT 1
)
UPDATE public.community_announcements
SET created_by = admin_profile.user_id
FROM admin_profile
WHERE created_by IS NULL;

WITH admin_profile AS (
  SELECT user_id
  FROM public.user_profiles
  WHERE role = 'admin'
  ORDER BY created_at
  LIMIT 1
)
UPDATE public.community_challenge_announcements
SET created_by = admin_profile.user_id
FROM admin_profile
WHERE created_by IS NULL;

WITH admin_profile AS (
  SELECT user_id
  FROM public.user_profiles
  WHERE role = 'admin'
  ORDER BY created_at
  LIMIT 1
)
UPDATE public.community_assessment_announcements
SET created_by = admin_profile.user_id
FROM admin_profile
WHERE created_by IS NULL;

WITH admin_profile AS (
  SELECT user_id
  FROM public.user_profiles
  WHERE role = 'admin'
  ORDER BY created_at
  LIMIT 1
)
UPDATE public.community_quiz_announcements
SET created_by = admin_profile.user_id
FROM admin_profile
WHERE created_by IS NULL;


-- Automatically map created_by to the caller's profile when possible
CREATE OR REPLACE FUNCTION public.set_created_by_profile()
RETURNS trigger
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_profile_id uuid;
BEGIN
  IF NEW.created_by IS NOT NULL THEN
    RETURN NEW;
  END IF;

  IF auth.uid() IS NULL THEN
    RETURN NEW;
  END IF;

  SELECT id
    INTO v_profile_id
    FROM public.user_profiles
    WHERE user_id = auth.uid()
    LIMIT 1;

  IF FOUND THEN
    NEW.created_by = v_profile_id;
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS set_affirmations_created_by ON public.affirmations;
CREATE TRIGGER set_affirmations_created_by
  BEFORE INSERT ON public.affirmations
  FOR EACH ROW
  EXECUTE FUNCTION public.set_created_by_profile();

DROP TRIGGER IF EXISTS set_challenge_templates_created_by ON public.challenge_templates;
CREATE TRIGGER set_challenge_templates_created_by
  BEFORE INSERT ON public.challenge_templates
  FOR EACH ROW
  EXECUTE FUNCTION public.set_created_by_profile();
